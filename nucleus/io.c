/*
 * Copyright (c) 2007 Josef 'Jeff' Sipek
 */

#include <io.h>
#include <interrupt.h>
#include <sched.h>
#include <atomic.h>
#include <buddy.h>

u8 *io_stack_ptr;

static atomic_t ops_used;		/* # of used slots in ops[] */
static struct io_op_inflight_entry ops[MAX_IOS];
					/* in-flight I/O ops */

/*
 * Helper function to make sure the io_op has everything set right
 */
static int __verify_io_op(struct io_op *ioop)
{
	// FIXME: check everything that makes sense to check
	return 0;
}

static void __reset_reserved_fields(struct io_op *ioop)
{
	ioop->orb.__zero1 = 0;
	ioop->orb.__zero2 = 0;

	ioop->orb.__reserved1 = 0;
	ioop->orb.__reserved2 = 0;
	ioop->orb.__reserved3 = 0;
	ioop->orb.__reserved4 = 0;
	ioop->orb.__reserved5 = 0;
	ioop->orb.__reserved6 = 0;
}

/*
 * Submit an I/O request to a subchannel, and set up everything needed to
 * handle the operation
 */
int submit_io(struct io_op *ioop, int flags)
{
	int i;
	int err = -EBUSY;

	if (!atomic_add_unless(&ops_used, 1, MAX_IOS))
		goto out;

	err = __verify_io_op(ioop);
	if (err)
		goto out;

	/* make sure all reserved fields have the right values */
	__reset_reserved_fields(ioop);

	ioop->err = 0;
	atomic_set(&ioop->done, 0);

	/* find an unused slot */
	for(i=0; i<MAX_IOS; i++) {
		if (atomic_add_unless(&ops[i].used, 1, 1))
			break;
	}

	BUG_ON(i == MAX_IOS);

	/* save I/O op pointer */
	ops[i].op = ioop;
	ioop->orb.param = i + IO_PARAM_BASE;

	/*
	 * Set the subsystem ID & issue SSCH on the ORB
	 */
	asm volatile(
		"	sr	%%r1,%%r1\n"
		"	a	%%r1,0(%%r1,%0)\n"
		"	ssch	0(%2)\n"
		: /* output */
		: /* input */
		  "a" (&ioop->ssid),
		  "m" (ioop->orb),
		  "a" (&ioop->orb)
		: /* clobbered */
		  "cc", "r1"
	);
	
	err = 0;
out:
	return err;
}

/*
 * Initialize the channel I/O subsystem
 */
void init_io()
{
	int i;
	struct page *page;
	u64 cr6;

	page = alloc_pages(0);
	BUG_ON(!page);

	io_stack_ptr = PAGE_SIZE + (u8*)page_to_addr(page);

	for(i=0; i<MAX_IOS; i++) {
		ops[i].op = NULL;
		atomic_set(&ops[i].used, 0);
	}

	atomic_set(&ops_used, 0);

	/* enable all I/O interrupt classes */
	asm volatile(
		"stctg	6,6,%0\n"	/* get cr6 */
		"oi	%1,0xff\n"	/* enable all */
		"lctlg	6,6,%0\n"	/* reload cr6 */
	: /* output */
	: /* input */
	  "m" (cr6),
	  "m" (*(u64*) (((u8*)&cr6) + 4))
	);
}

/*
 * I/O Interrupt handler (C portion)
 */
void __io_int_handler()
{
	struct irb irb;
	struct io_op *cur_op;
	int op_idx;

	/*
	 * make sure we don't overrun the ops array; if the parameter is
	 * larger than the size of our array, then we just ignore this
	 * interrupt - not ideal, but it means that we didn't call for it,
	 * and therefore we cannot be sure what to do with it!
	 *
	 * NOTE: If I/O interrupts are generated by terminals, this will
	 * have to change to handle the cases where I/O is generated without
	 * us starting it.
	 */
	op_idx = IO_INT_CODE->param - IO_PARAM_BASE;
	if (op_idx >= MAX_IOS || op_idx < 0)
		return;

	cur_op = ops[op_idx].op;
	if (!cur_op)
		return;

	asm volatile(
		"L	%%r1, %0\n"
		"TSCH	%1\n"
	: /* output */
	: /* input */
	  "m" (cur_op->ssid),
	  "m" (irb)
	: /* clobbered */
	  "r1"
	);

	if (cur_op->handler)
		cur_op->handler(cur_op, &irb);

	/*
	 * We can do this, because the submit_io function resets ->err to
	 * zero, and therefore regardless of ->handler being defined, ->err
	 * will have a reasonable value
	 */
	if (cur_op->err == -EAGAIN)
		return; /* leave handler registered */

	/* flag io_op as done... */
	atomic_set(&cur_op->done, 1);

	/* ...and remove it form the list */
	ops[op_idx].op = NULL;
	atomic_dec(&ops[op_idx].used);
	atomic_dec(&ops_used);

	/* call the destructor if there is one */
	if (cur_op->dtor)
		cur_op->dtor(cur_op);
}
