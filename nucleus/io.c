/*
 * Copyright (c) 2007 Josef 'Jeff' Sipek
 */

#include <io.h>
#include <interrupt.h>
#include <sched.h>
#include <atomic.h>

static atomic_t ops_used;		/* # of used slots in ops[] */
static struct io_op_inflight_entry ops[MAX_IOS];
					/* in-flight I/O ops */

/*
 * Helper function to make sure the io_op has everything set right
 */
static int __verify_io_op(struct io_op *ioop)
{
	// FIXME: check everything that makes sense to check
	return 0;
}

static void __reset_reserved_fields(struct io_op *ioop)
{
	ioop->orb.__zero1 = 0;
	ioop->orb.__zero2 = 0;

	ioop->orb.__reserved1 = 0;
	ioop->orb.__reserved2 = 0;
	ioop->orb.__reserved3 = 0;
	ioop->orb.__reserved4 = 0;
	ioop->orb.__reserved5 = 0;
	ioop->orb.__reserved6 = 0;
}

/*
 * Submit an I/O request to a subchannel, and set up everything needed to
 * handle the operation
 */
int submit_io(struct io_op *ioop, int flags)
{
	int i;
	int err = -EBUSY;

	if (!atomic_add_unless(&ops_used, 1, MAX_IOS))
		goto out;

	err = __verify_io_op(ioop);
	if (err)
		goto out;

	/* make sure all reserved fields have the right values */
	__reset_reserved_fields(ioop);

	ioop->err = 0;
	ioop->done = 0;

	/* find an unused slot */
	for(i=0; i<MAX_IOS; i++) {
		if (atomic_add_unless(&ops[i].used, 1, 1))
			break;
	}

	BUG_ON(i == MAX_IOS);

	/* save I/O op pointer */
	ops[i].op = ioop;
	ioop->orb.param = i;

	/*
	 * Set the subsystem ID & issue SSCH on the ORB
	 */
	asm volatile(
		"	sr	%%r1,%%r1\n"
		"	a	%%r1,0(%%r1,%0)\n"
		"	ssch	0(%2)\n"
		: /* output */
		: /* input */
		  "a" (&ioop->ssid),
		  "m" (ioop->orb),
		  "a" (&ioop->orb)
		: /* clobbered */
		  "cc", "r1"
	);
	
	err = 0;
out:
	return err;
}

/*
 * Initialize the channel I/O subsystem
 */
void init_io()
{
	int i;

	for(i=0; i<MAX_IOS; i++) {
		ops[i].op = NULL;
		atomic_set(&ops[i].used, 0);
	}

	atomic_set(&ops_used, 0);

	// FIXME: enable I/O interrupts
}

/*
 * I/O Interrupt handler (C portion)
 */
void __io_int_handler()
{
	struct irb irb;
	struct io_op *cur_op;

	/*
	 * make sure we don't overrun the ops array; if the parameter is
	 * larger than the size of our array, then we just ignore this
	 * interrupt - not ideal, but it means that we didn't call for it,
	 * and therefore we cannot be sure what to do with it!
	 *
	 * NOTE: If I/O interrupts are generated by terminals, this will
	 * have to change to handle the cases where I/O is generated without
	 * us starting it.
	 */
	if (IO_INT_CODE->param >= MAX_IOS)
		return;

	cur_op = ops[IO_INT_CODE->param].op;
	if (!cur_op)
		return;

	if (cur_op->handler)
		cur_op->handler(cur_op, &irb);

	/*
	 * We can do this, because the submit_io function resets ->err to
	 * zero, and therefore regardless of ->handler being defined, ->err
	 * will have a reasonable value
	 */
	if (cur_op->err == -EAGAIN)
		return; /* leave handler registered */

	/* flag io_op as done... */
	cur_op->done = 1;

	/* ...and remove it form the list */
	ops[IO_INT_CODE->param].op = NULL;
	atomic_dec(&ops[IO_INT_CODE->param].used);
	atomic_dec(&ops_used);
}
