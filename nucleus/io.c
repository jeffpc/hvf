/*
 * Copyright (c) 2007 Josef 'Jeff' Sipek
 */

#include <channel.h>
#include <io.h>
#include <interrupt.h>
#include <sched.h>
#include <atomic.h>
#include <buddy.h>

static atomic_t ops_used;		/* # of used slots in ops[] */
static struct io_op_inflight_entry ops[MAX_IOS];
					/* in-flight I/O ops */

/*
 * Helper function to make sure the io_op has everything set right
 */
static int __verify_io_op(struct io_op *ioop)
{
	// FIXME: check everything that makes sense to check
	return 0;
}

static void __reset_reserved_fields(struct io_op *ioop)
{
	ioop->orb.__zero1 = 0;
	ioop->orb.__zero2 = 0;

	ioop->orb.__reserved1 = 0;
	ioop->orb.__reserved2 = 0;
	ioop->orb.__reserved3 = 0;
	ioop->orb.__reserved4 = 0;
	ioop->orb.__reserved5 = 0;
	ioop->orb.__reserved6 = 0;
}

/*
 * Submit an I/O request to a subchannel, and set up everything needed to
 * handle the operation
 */
int submit_io(struct io_op *ioop, int flags)
{
	int i;
	int err = -EBUSY;

	if (!atomic_add_unless(&ops_used, 1, MAX_IOS))
		goto out;

	err = __verify_io_op(ioop);
	if (err)
		goto out_dec;

	/* make sure all reserved fields have the right values */
	__reset_reserved_fields(ioop);

	ioop->err = 0;
	atomic_set(&ioop->done, 0);

	/* find an unused slot */
	for(i=0; i<MAX_IOS; i++) {
		if (atomic_add_unless(&ops[i].used, 1, 1))
			break;
	}

	BUG_ON(i == MAX_IOS);

	/* save I/O op pointer */
	ops[i].op = ioop;
	ioop->orb.param = i + IO_PARAM_BASE;

	/* Start the I/O */
	err = start_sch(ioop->ssid, &ioop->orb);
	if (!err)
		goto out;

	/* error while submitting I/O, let's unregister */
	ops[i].op = NULL;
	atomic_dec(&ops[i].used);

out_dec:
	atomic_dec(&ops_used);
out:
	return err;
}

/*
 * Initialize the channel I/O subsystem
 */
void init_io()
{
	int i;
	u64 cr6;

	for(i=0; i<MAX_IOS; i++) {
		ops[i].op = NULL;
		atomic_set(&ops[i].used, 0);
	}

	atomic_set(&ops_used, 0);

	/* enable all I/O interrupt classes */
	asm volatile(
		"stctg	6,6,%0\n"	/* get cr6 */
		"oi	%1,0xff\n"	/* enable all */
		"lctlg	6,6,%0\n"	/* reload cr6 */
	: /* output */
	: /* input */
	  "m" (cr6),
	  "m" (*(u64*) (((u8*)&cr6) + 4))
	);
}

static int default_io_handler(struct io_op *ioop, struct irb *irb)
{
	/* if Device End is NOT set, keep waiting */
	if (!(irb->status.dev_status & 0x04))
		ioop->err = -EAGAIN;
	return 0;
}

/*
 * I/O Interrupt handler (C portion)
 */
void __io_int_handler()
{
	struct irb irb;
	struct io_op *cur_op;
	int op_idx;

	/*
	 * make sure we don't overrun the ops array; if the parameter is
	 * larger than the size of our array, then we just ignore this
	 * interrupt - not ideal, but it means that we didn't call for it,
	 * and therefore we cannot be sure what to do with it!
	 *
	 * NOTE: If I/O interrupts are generated by terminals, this will
	 * have to change to handle the cases where I/O is generated without
	 * us starting it.
	 */
	op_idx = IO_INT_CODE->param - IO_PARAM_BASE;
	if (op_idx >= MAX_IOS || op_idx < 0)
		return;

	cur_op = ops[op_idx].op;
	if (!cur_op)
		return;

	cur_op->err = test_sch(cur_op->ssid, &irb);
	BUG_ON(cur_op->err);

	if (!cur_op->err && cur_op->handler)
		cur_op->handler(cur_op, &irb);
	else
		default_io_handler(cur_op, &irb);

	/*
	 * We can do this, because the submit_io function resets ->err to
	 * zero, and therefore regardless of ->handler being defined, ->err
	 * will have a reasonable value
	 */
	if (cur_op->err == -EAGAIN)
		return; /* leave handler registered */

	/* flag io_op as done... */
	atomic_set(&cur_op->done, 1);

	/* ...and remove it form the list */
	ops[op_idx].op = NULL;
	atomic_dec(&ops[op_idx].used);
	atomic_dec(&ops_used);

	/* call the destructor if there is one */
	if (cur_op->dtor)
		cur_op->dtor(cur_op);
}
